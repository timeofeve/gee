# gee
学习gee


### range
遍历各种集合

### 函数
```
keyword   函数名  传入参数  返回类型
func      Intn   (n  int)  int
                 名 类型              

# 使用
       包.函数名(参数)
num := rand.Intn(10)
```
- 大写开头函数可以被外部调用,小写字母开头不可以。
- 函数声明-多个参数
> 函数的多个返回值需要用括号括起来，每个返回值名字在前，类型在后。 声明函数时可以把名字去掉，只保留类型： func Atoi(s string) (int, error)
- 形式参数: parameter(定义时) 
- 实际参数: argument(使用时)
### 方法
```
keyword receiver  method    result
  |         |      name      |
  |         |       |        |
func   (k kelvin) celsius() celsius
       name type             type
```
### 一等函数
```
在go里，函数是头等，它可以用在整数、字符串或其他类型能用的地方：
  将函数赋给变量
  将函数作为参数传递给函数
  将函数作为函数的返回类型

闭包和匿名函数
  匿名函数就是没有名字的函数，在go中也称为函数的字面值
  因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的
  闭包(closure) 就是由于匿名函数封闭并包围作用域中的变量而的名
```
### 数组
```
数组是一种固定长度且有序的元素集合
数组访问通过[]和从0开始的索引进行访问
数组的长度可用内置函数len获取
在声明数组时，未被赋值元素的值是对应类型的零值

数组越界
 访问超过数组长度时

复合字面值初始化数组
 d := [3]string{"a", "b", "c", "d"}
 在复合字面值里使用 ... 作为数组长度，这样go编译器算出数组元素数量
 无论那种方式，数组的长度都是固定的

遍历数组
 for遍历
 range

数组的复制
   无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本
   数组也是一种值，函数通过值传递来接受参数，所以数组作为函数的参数就非常低效
   数组长度也是数据类型的一部分

数组的数组(二维数组)
```
### 切片
```
切片指向数组的窗口
  假设 planets 是个数组，那么 planets[0:4]是一个切片，切分出数组前4的元素，表达式中 [起始位:结束位]
  切分数组不会导致数据被修改，只是创建一个指向数组的窗口或视图，这就是slice类型
  slice使用的左闭右开区间
     例 planets[0:4] 包含索引0，1，2，3 不包括4
  slice的索引不可以是负数
  切分字符串时，索引代表的是字节数而非 rune数
  TrimSpace去除字符前后空白字符
  // Join 将 a 中的子串连接成一个单独的字符串，子串之间用 sep 分隔
  func Join(a []string, sep string) string
```
### append 函数
```
append 函数为内置函数，它可以将元素添加到slice里面
```
### 长度与容量(length capacity)
```
切片的长度是它所包含的元素个数。
切片的容量是从它的第一个元素到其底层数组元素末尾的个数。
切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。
```
### make函数对slice进行预分配
```
尽量避免面额外的内存分配和数组复制操作
//用make()函数来创建切片：var 变量名 = make([]变量类型,长度,容量)
var s = make([]int, 0, 5)
```
### map 集合
```
可以将key映射到value
快速通过key找到对应的value
key几乎可以是任何类型

    key type value type
       |      |
map [string] int

map不会被复制
```
### map 用作set
```
set集合与数组类似，但元素不会重复
go中没提供set集合
```