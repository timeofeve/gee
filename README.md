# gee
学习gee


### range
遍历各种集合

### 函数
```
keyword   函数名  传入参数  返回类型
func      Intn   (n  int)  int
                 名 类型              

# 使用
       包.函数名(参数)
num := rand.Intn(10)
```
- 大写开头函数可以被外部调用,小写字母开头不可以。
- 函数声明-多个参数
> 函数的多个返回值需要用括号括起来，每个返回值名字在前，类型在后。 声明函数时可以把名字去掉，只保留类型： func Atoi(s string) (int, error)
- 形式参数: parameter(定义时) 
- 实际参数: argument(使用时)
### 方法
```
keyword receiver  method    result
  |         |      name      |
  |         |       |        |
func   (k kelvin) celsius() celsius
       name type             type
```
### 一等函数
```
在go里，函数是头等，它可以用在整数、字符串或其他类型能用的地方：
  将函数赋给变量
  将函数作为参数传递给函数
  将函数作为函数的返回类型

闭包和匿名函数
  匿名函数就是没有名字的函数，在go中也称为函数的字面值
  因为函数字面值需要保留外部作用域的变量引用，所以函数字面值都是闭包的
  闭包(closure) 就是由于匿名函数封闭并包围作用域中的变量而的名
```
### 数组
```
数组是一种固定长度且有序的元素集合
数组访问通过[]和从0开始的索引进行访问
数组的长度可用内置函数len获取
在声明数组时，未被赋值元素的值是对应类型的零值

数组越界
 访问超过数组长度时

复合字面值初始化数组
 d := [3]string{"a", "b", "c", "d"}
 在复合字面值里使用 ... 作为数组长度，这样go编译器算出数组元素数量
 无论那种方式，数组的长度都是固定的

遍历数组
 for遍历
 range

数组的复制
   无论数组赋值给新的变量还是将它传递给函数，都会产生一个完整的数组副本
   数组也是一种值，函数通过值传递来接受参数，所以数组作为函数的参数就非常低效
   数组长度也是数据类型的一部分

数组的数组(二维数组)
```
### 切片
```
切片指向数组的窗口
  假设 planets 是个数组，那么 planets[0:4]是一个切片，切分出数组前4的元素，表达式中 [起始位:结束位]
  切分数组不会导致数据被修改，只是创建一个指向数组的窗口或视图，这就是slice类型
  slice使用的左闭右开区间
     例 planets[0:4] 包含索引0，1，2，3 不包括4
  slice的索引不可以是负数
  切分字符串时，索引代表的是字节数而非 rune数
  TrimSpace去除字符前后空白字符
  // Join 将 a 中的子串连接成一个单独的字符串，子串之间用 sep 分隔
  func Join(a []string, sep string) string
```
### append 函数
```
append 函数为内置函数，它可以将元素添加到slice里面
```
### 长度与容量(length capacity)
```
切片的长度是它所包含的元素个数。
切片的容量是从它的第一个元素到其底层数组元素末尾的个数。
切片 s 的长度和容量可通过表达式 len(s) 和 cap(s) 来获取。
```
### make函数对slice进行预分配
```
尽量避免面额外的内存分配和数组复制操作
//用make()函数来创建切片：var 变量名 = make([]变量类型,长度,容量)
var s = make([]int, 0, 5)
```
### map 集合
```
可以将key映射到value
快速通过key找到对应的value
key几乎可以是任何类型

    key type value type
       |      |
map [string] int

map不会被复制
```
### map 用作set
```
set集合与数组类似，但元素不会重复
go中没提供set集合
go中没提供set集合,可以使用map构造一个
```
### struct 结构体
```
变量结构体
var test struct{}

类行结构体,可以复用
type test struct{}

整合分散零件为一个完整的结构体
struct 允许将不同的类型东西结合在一起
```
### struct 编码为json
```
json包中的Marshal函数可以将struct 中的数据转化为JSON格式
Marshal函数只会对struct中被导出的字段进行编码
```
### go中没有class类
```
go和其他经典语言不同，没得class，没有对象，也没有继承
但是go提供struct和方法可以实现对象
```
### 接口
```
接口关注于类型可以做什么，而不是存储了什么
接口通过列举类型必须满足的一组方法来进行声明
go中不需要声明接口

接口类型 约定以 er解为
type talker interface {
       talk() string
}
```
### 指针
```
指针是指向另一个变量地址的变量
go语言的指针同事也强调安全性，不会出现迷途指针

& 符号加变量，可以获得变量在内存中的地址
& 符号无法获得字符串/数值/布尔字面值的地址

* 操作符于&的作用相反，它用来解引用，提供内存地址指向的值
访问字段时，对结构体进行解引用并不是必须的

指针类型: 指针存储的是内存地址

```
### silce指向数组
```
slice是指向数组的窗口，实际上slice在指向数组元素的时候也使用了指针
每个slice内部都会被表示为一个包含3个元素的结构，他们分别指向：
  数组的指针
  slice的容量
  slice的长度
当slice被直接传递至函数或方法时，slice的内部指针就可以对底层数据进行修改；
指向slice的显式指针的唯一作用就是修改slice本身，slice的长度、容量以及起始偏移量
```
### nil
```
nil 是个名词，表示 “无“ 或者 “零”
go中nil是个零值，指针没有明确的指向，它的值就是nil，
nil还是silce、map和接口的零值
```
### 错误处理
```
defer关键字，go可以确保所有的deferred的动作可以在函数返回前执行
可以defer任意的函数和方法
defer并不是专门做错误处理的
defer可以消除必须时刻惦记执行资源释放的负担
```
### goroutine
```
go中，独立任务叫做goroutine,类似其他语言中的 协程、进程、线程，但又不完全相同，
goroutine 创建效率非常高，
go能直接了当的协同多个并发 concurrent操作

只需要在调用前面加一个go关键字就可启动goroutine

表面goroutine在同时运行，实际技术上不是，计算机处理器用 “分时” 技术，在多个goroutine上轮流花费一些时间
```
### channel 通道
```
channel可以用在多个goroutine之间安全传值
通道可以作变量、函数参数、结构体字段。。。
创建通道用 make 函数，并指定其传输数据的类型
    c := make(chan int)
使用左箭头操作符 <- 向通道 发送值 或 接受值
发送 c <- 99
接受 r := <- c
执行发送操作的goroutin在等待期间将无法进行其他操作，未等待的可以进行其他操作

如果不适用make初始化通道，那么通道变量值就是nil(零值)
对nil通道进行发送或者接收不会引起panic，但是会导致永久阻塞
对nil通道执行close函数，那么会引起panic
nil通道的用处：
   对于包含select语句的循环，如果不希望每次循环都等待select所涉及的所有通道，那么可以先某些通道设为nil，等到发送值准备就绪之后，在将通道变成一个非nil值并执行发送操作
```
### 阻塞和死锁
```
当goroutine在等待通道的发送或接收时，就说它被阻塞
出了会占用少量内存外，被阻塞的goroutine并不消耗其他任何资源
当多个或一个goroutine因某些永久无法发生的事被阻塞时，称为死锁，出现死锁程序通常会崩溃或挂起

go允许没有值可以发送的情况下通过close函数关闭通道 close(c)
通道被关闭后无法写入任何值，如果尝试写入将引发panic
尝试读取 被关闭的通道会 获取与通道类型 对应的零值

注意: 如果循环里读取一个已经关闭的通道，未检查是否关闭，循环将一直运行，消耗大量cpu时间
检查通道是否被关闭, ok 为布尔类型，false就是关闭了
 v, ok := <- c
```
### 并发
```
go中的互斥锁(mutex = mutual exclusive), 由sync 包提供
Lock() Unlock()
互斥锁定义在被保护的变量之上

为了保证互斥锁的安全使用，需遵守一下规则
  尽可能的简化互斥锁保护的代码
  对每一份共享状态只使用一个互斥锁

工作进程 worker
  通常会被写成包含 select 语句的 for循环
  
```